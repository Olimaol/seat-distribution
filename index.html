<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Seat Distribution</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 1rem; background: #f5f5f5; margin: 0; }
    .controls { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem; }
    .controls label, .controls button { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: white; border-radius: 8px; flex: 1 1 120px; }
    .controls input[type="number"] { width: 100%; max-width: 60px; padding: 0.25rem; font-size: 1rem; }
    .controls input[type="checkbox"] { transform: scale(1.2); }
    .controls button { cursor: pointer; border: none; background: #4caf50; color: white; border-radius: 4px; transition: background 0.2s; }
    .controls button:hover { background: #45a049; }
    .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
    .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background-color: #4caf50; }
    input:checked + .slider:before { transform: translateX(26px); }
    .info { margin-bottom: 1rem; font-weight: bold; }
    .grid-container { overflow: auto; background: #ddd; padding: 0.5rem; border-radius: 8px; max-height: 60vh; scrollbar-width: thin; scrollbar-color: #888 #ddd; -webkit-overflow-scrolling: touch; }
    .grid-container::-webkit-scrollbar { width: 8px; height: 8px; }
    .grid-container::-webkit-scrollbar-track { background: #ddd; border-radius: 4px; }
    .grid-container::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
    .grid { display: grid; user-select: none; }
    .cell { border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; background: white; cursor: pointer; transition: background 0.2s; }
    .cell.available { background: #cce5ff; }
    .cell.student { background: #8bc34a; }
    @media (max-width: 600px) { .controls { flex-direction: column; } }
  </style>
</head>
<body>
  <div class="controls">
    <label>Rows: <input type="number" id="rows" min="1" value="15"></label>
    <label>Columns: <input type="number" id="cols" min="1" value="15"></label>
    <label>Spacing: <input type="number" id="spacing" min="0" value="1"></label>
    <label><input type="checkbox" id="emptyRows"> Every 2nd row empty</label>
    <label><input type="checkbox" id="edgeSeats"> Allow edge seating</label>
    <label>Lock:<label class="switch"><input type="checkbox" id="lockToggle"><span class="slider"></span></label></label>
    <button id="undoBtn">Undo</button>
    <button id="resetBtn">Reset</button>
  </div>
  <div class="info">Distributed Students: <span id="studentCount">0</span></div>
  <div class="grid-container"><div id="grid" class="grid"></div></div>
  <script>
    const isMobile = 'ontouchstart' in window;
    const gridEl = document.getElementById('grid');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const spacingInput = document.getElementById('spacing');
    const emptyRowsInput = document.getElementById('emptyRows');
    const lockToggle = document.getElementById('lockToggle');
    const edgeSeatsInput = document.getElementById('edgeSeats');
    const studentCountEl = document.getElementById('studentCount');
    const undoBtn = document.getElementById('undoBtn');
    const resetBtn = document.getElementById('resetBtn');

    let rows = +rowsInput.value, cols = +colsInput.value;
    let spacing = +spacingInput.value, emptyRows = emptyRowsInput.checked;
    let allowEdge = edgeSeatsInput.checked, locked = lockToggle.checked;
    let selecting = false, startCell = null;
    let available = new Set(), baseAvailable = new Set();
    const history = [];
    undoBtn.style.display = isMobile ? 'inline-flex' : 'none';

    function buildGrid() {
      gridEl.innerHTML = '';
      const cellSize = isMobile ? 24 : 30;
      gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
      gridEl.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell'; cell.dataset.r = r; cell.dataset.c = c;
          cell.style.width = cell.style.height = cellSize + 'px';
          gridEl.append(cell);
        }
      }
      bindEvents(); updateCount(0);
    }

    function bindEvents() {
      gridEl.querySelectorAll('.cell').forEach(cell => {
        cell.addEventListener(isMobile ? 'touchstart' : 'mousedown', e => handleDown(e, cell));
        if (!isMobile) cell.addEventListener('mouseenter', e => selecting && updateSel(e));
      });
      if (isMobile) {
        gridEl.addEventListener('touchmove', handleMove, { passive: true });
      }
      document.addEventListener(isMobile ? 'touchend' : 'mouseup', () => selecting = false);
      undoBtn.onclick = undo; resetBtn.onclick = reset;
    }

    function handleDown(e, cell) {
      if (locked) return;
      // On mobile, only handle single finger touches for selection
      if (isMobile && e.touches && e.touches.length > 1) return;
      // Don't prevent default on mobile to allow scrolling
      if (!isMobile) {
        e.preventDefault();
      }
      selecting = true;
      const ctrl = !isMobile && e.ctrlKey;
      startCell = cell;
      baseAvailable = ctrl ? new Set(available) : (isMobile ? new Set(available) : new Set());
      if (isMobile) history.push(new Set(available));
      updateSel({ target: cell });
    }

    function handleMove(e) {
      // Only handle single finger touches for selection
      if (e.touches.length > 1) return;
      const touch = e.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (selecting && target?.classList.contains('cell')) updateSel({ target });
    }

    function updateSel(e) {
      const end = e.target;
      available = new Set(baseAvailable);
      const r1 = +startCell.dataset.r, c1 = +startCell.dataset.c;
      const r2 = +end.dataset.r, c2 = +end.dataset.c;
      const rStart = Math.min(r1, r2), rEnd = Math.max(r1, r2);
      const cStart = Math.min(c1, c2), cEnd = Math.max(c1, c2);
      for (let r = rStart; r <= rEnd; r++) for (let c = cStart; c <= cEnd; c++) available.add(`${r},${c}`);
      render();
    }

    function undo() { if (isMobile && history.length) { available = history.pop(); render(); }}
    function reset() { history.length = 0; available.clear(); render(); }

    function render() {
      gridEl.querySelectorAll('.cell').forEach(cell => {
        const k = `${cell.dataset.r},${cell.dataset.c}`;
        cell.classList.toggle('available', available.has(k)); cell.classList.remove('student');
      });
      if (locked) { const cnt = distribute(); updateCount(cnt); } else updateCount(0);
    }

    function distribute() {
      let maxRow = 0, maxCount = -1;
      for (let r = 0; r < rows; r++) {
        if (emptyRows && r % 2) continue;
        let cnt = 0;
        for (let c = 0; c < cols; c++) if (available.has(`${r},${c}`) && (allowEdge || (c >= spacing && c < cols - spacing))) cnt++;
        if (cnt > maxCount) { maxCount = cnt; maxRow = r; }
      }
      if (maxCount < 1) return 0;
      let best = { score: -1, cols: [] };
      for (let shift = 0; shift <= spacing; shift++) {
        const cand = [];
        for (let c = 0; c < cols; c++) {
          if (!allowEdge && (c < spacing || c >= cols - spacing)) continue;
          if ((c - shift) % (spacing + 1)) continue;
          if (available.has(`${maxRow},${c}`)) cand.push(c);
        }
        let score = 0; cand.forEach(c => { for (let r = 0; r < rows; r++) if (!(emptyRows && r % 2) && available.has(`${r},${c}`)) score++; });
        if (score > best.score) best = { score, cols: cand };
      }
      best.cols.forEach(c => { for (let r = 0; r < rows; r++) if (!(emptyRows && r % 2) && available.has(`${r},${c}`)) gridEl.querySelector(`[data-r='${r}'][data-c='${c}']`).classList.add('student'); });
      return best.cols.reduce((sum, c) => sum + [...Array(rows).keys()].filter(r => !(emptyRows && r % 2) && available.has(`${r},${c}`)).length, 0);
    }

    function updateCount(n) { studentCountEl.textContent = n; }

    [rowsInput, colsInput].forEach(i => i.onchange = () => { rows = +rowsInput.value; cols = +colsInput.value; available.clear(); history.length = 0; buildGrid(); });
    spacingInput.onchange = () => { spacing = +spacingInput.value; locked && render(); };
    emptyRowsInput.onchange = () => { emptyRows = emptyRowsInput.checked; locked && render(); };
    edgeSeatsInput.onchange = () => { allowEdge = edgeSeatsInput.checked; locked && render(); };
    lockToggle.onchange = () => { locked = lockToggle.checked; render(); };

    buildGrid();
  </script>
</body>
</html>
